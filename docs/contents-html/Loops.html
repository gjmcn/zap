<h2>Loops</h2>
<hr>
<h4 id="each"><code>each</code></h4>
<p>The first operand of <code>each</code> is the iterable to loop over; the final operand is the loop <a href="?Syntax#body-rules">body</a>. Between these, we can provide optional <em>loop parameters</em> for the current value, current index and the iterable:</p>
<pre><code>// body in parentheses, prints: 4 5 6
@ 4 5 6 each x (print x)

// body is an indented block, prints: 4,0 5,1 6,2
@ 4 5 6 each x i
    + x','i
</code></pre>
<hr>
<h4 id="map"><code>map</code></h4>
<p>!!!!!!!!!!!!!!!!!HERE!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</p>
<hr>
<h4 id="do"><code>do</code></h4>
<hr>
<h4 id="async-loops"><code>asyncEach</code>, <code>asyncMap</code>, <code>asyncDo</code></h4>
<p>Asynchronous versions of <a href="#each"><code>each</code></a>, <a href="#map"><code>map</code></a> and <a href="#do"><code>do</code></a>. These operators return a promise that resolves to the equivalent of that returned by the synchrnous version of the operator.</p>
<p><code>await</code> can be used in body of asynchronous loops, regardless of the parent scope  -- USE ASYNCSCOPE ...</p>
<p>In the following example, we use an <code>asyncScope</code> so that we can</p>
<pre><code>

</code></pre>
<hr>
<h4 id="loop-variables">Loop Parameters and Variables</h4>
<p>Loop parameters and any variables created inside the loop body are local to each step of the loop — they are effectively created fresh each step.</p>
<hr>
<h4 id="stop">Breaking from Loops</h4>
<hr>
<h4 id="yield-in-loops">Using 'yield'</h4>
<hr>
<p>Use <code>$each</code> or <code>$map</code> to loop over an iterable. <code>$each</code> and <code>$map</code> are passed an iterable and a callback function; <code>$each</code> returns the iterable whereas <code>$map</code> collects the values returned by the callback in an array:</p>
<pre><code>x = @ 5 6;
x $each [a $print];   // prints 5 6, returns x 
x $map [a + 10];      // [15, 16]

o = # u 5 v 6;
Object |values o $map [a + 10];   // [15, 16]

m = ## u 5 v 6;            // Map {'u' =&gt; 5, 'v' =&gt; 6}
m |values $map [a + 10];   // [15, 16]
</code></pre>
<p>The callback is passed the 'current index' as its second argument and the iterable as the third argument:</p>
<pre><code>@ 5 6 7 $map [b];         // [0, 1, 2]
@ 5 6 7 $map [c |join];   // ['5,6,7', '5,6,7', '5,6,7']
</code></pre>
<p>If used with a single operand (a function), <code>$each</code> and <code>$map</code> automatically create an 'infinite generator' that yields <code>undefined</code> until its <code>return</code> method is called:</p>
<pre><code>// prints 0 1 2 3
$each [
  b $print;
  b == 3 ? (c |return)];
</code></pre>
<blockquote>
<p>Calling a generator's <code>return</code> method exits a loop <em>at the end</em> of the current step.</p>
</blockquote>
<blockquote>
<p>When <code>$each</code> or <code>$map</code> is used with a single operand, the loop has at least one step. Use <a href="?Generators#do-and-while"><code>$while</code></a> when the loop may have zero steps.</p>
</blockquote>
<blockquote>
<p>Operators for working with iterables (including the operators in this section, but also see e.g. <a href="?Reduce">Reduce</a>, <a href="?Filter-and-Group">Filter and Group</a>, <a href="?Order-and-Bin">Order and Bin</a>, <a href="?Backticks">Backticks</a> and <a href="?Tabular-Data">Tabular Data</a>) treat empty array elements as normal elements (with value <code>undefined</code>). In contrast, some array methods ignore empty elements.</p>
</blockquote>
<h4 id="async-loops">Asynchronous Loops</h4>
<p>The callback function of <code>$each</code> or <code>$map</code> can be asynchronous:</p>
<pre><code>// web service that returns a random number
url = 'https://www.random.org/decimal-fractions/?num=1&amp;dec=10&amp;col=1&amp;format=plain&amp;rnd=new';

// prints 'done', then prints 3 random numbers
1 &gt;&gt; 3 $each {url \fetch $await |text $await $number $print};
$print 'done';
</code></pre>
<p>In the above example, the loop moves to the next step without waiting for the promise returned by the callback to resolve. If we had used <code>$map</code>, the returned array would contain the promises. In contrast to this behavior, <code>$awaitEach</code> and <code>$awaitMap</code> await both the iterable and the callback at each step. Like <code>$each</code> and <code>$map</code>, <code>$awaitEach</code> and <code>$awaitMap</code> use an infinite synchronous generator by default.</p>
<p><code>$awaitEach</code> and <code>$awaitMap</code> can only be used inside an asynchronous function:</p>
<pre><code>url = 'https://www.random.org/decimal-fractions/?num=1&amp;dec=10&amp;col=1&amp;format=plain&amp;rnd=new';

\{
  // prints random numbers until &gt; 0.9, then prints 'done'
  $awaitEach {
    x = url \fetch $await |text $await $number $print;
    x &gt; 0.9 ? (c |return)};
  $print 'done'};
</code></pre>
<p>As demonstrated in the above example, <code>$awaitEach</code> (and <code>$awaitMap</code>) is itself awaited — <code>'done'</code> is printed <em>after</em> the numbers are printed.</p>


<br><br><br>