<h2>Literals</h2>
<hr>
<h4>Basics</h4>
<pre><code>5           // 5 (number)
5.6         // 5.6 (number)
5e-2        // 0.05 (number)
'abc'       // 'abc' (string)
&quot;abc&quot;       // 'abc' (string)
&quot;a
bc&quot;         // 'a\nbc' (&quot;...&quot; strings can be multiline)
&amp;/abc/      // /abc/ (regular expression)
false       // false (boolean)
null        // null
undefined   // undefined
</code></pre>
<hr>
<h4 id="arrays-and-sets">Arrays and Sets</h4>
<p>Use the <code>@</code> operator for an array, and <code>@@</code> for a set:</p>
<pre><code>@        // empty array
@ 5 6    // [5, 6]

@@       // empty set
@@ 5 6   // Set {5, 6}
</code></pre>
<p>Note that <code>@@</code> interprets each operand as an element, whereas the <code>Set</code> constructor extracts elements from an iterable:</p>
<pre><code>@@ 'ab'        // Set {'ab'}
new Set 'ab'   // Set {'a', 'b'}
</code></pre>
<hr>
<h4 id="objects-and-maps">Objects and Maps</h4>
<p>Use the <code>#</code> operator for an object, and <code>##</code> for a map:</p>
<pre><code>#             // empty object
# u 5 v 6     // {u: 5, v: 6}

##            // empty map
## u 5 v 6    // Map {'u' =&gt; 5, 'v' =&gt; 6}
</code></pre>
<p><code>#</code> and <code>##</code> use the <a href="?Syntax#identifier-name-rule">identifier-name rule</a>, which is why the property names in the above examples need not be quoted.</p>


<br><br><br>