<h2>Generators</h2>
<hr>
<p>We can use a <a href="?Writing-Functions#generator-functions">generator function</a> to create a generator, but the operators described in this section are more convenient for many common tasks.</p>
<p>Since generators are iterables, they can be used with <a href="?Spread">spread syntax</a> and with many operators â€” see e.g. <a href="?Loops">Loops</a>, <a href="?Reduce">Reduce</a>, <a href="?Filter-and-Group">Filter and Group</a>, <a href="?Order-and-Bin">Order and Bin</a>, <a href="?Backticks">Backticks</a> and  <a href="?Assignment#Destructuring">Destructuring</a>. Here are some examples that use the <a href="#range"><code>&gt;&gt;</code></a> operator described below:</p>
<pre><code>r = 5 &gt;&gt; 7;   // generator (5 6 7)
r |next;      // {value: 5, done: false}
r |next;      // {value: 6, done: false}
r |next;      // {value: 7, done: false}
r |next;      // {value: undefined, done: true}

5 &gt;&gt; 7 $each [a $print];   // prints 5 6 7
5 &gt;&gt; 7 $array;             // [5, 6, 7]
@ ...(5 &gt;&gt; 7);             // [5, 6, 7]
@@ ...(5 &gt;&gt; 7);            // Set {5, 6, 7}
5 &gt;&gt; 7 $mean;              // 6
5 &gt;&gt; 7 `+ 10;              // [15, 16, 17]
u v w @= 5 &gt;&gt; 7;           // u is 5, v is 6, w is 7
</code></pre>
<hr>
<h5><code>&gt;&gt;</code> <code id="range">&gt;&gt;&gt;</code></h5>
<p>The range operator <code>&gt;&gt;</code> returns a generator that represents a sequence of equally spaced numbers. <code>&gt;&gt;</code> takes three operands: <em>start</em>, <em>end</em> and <em>step</em>. <em>step</em> is 1 by default:</p>
<pre><code>5 &gt;&gt; 7;        // generator (5 6 7)
1.5 &gt;&gt; 10 3;   // generator (1.5 4.5 7.5 9)
1 &gt;&gt; ~2 ~1;    // generator (1 0 -1 -2)
</code></pre>
<blockquote>
<p>Ranges created with <code>&gt;&gt;</code> can include <i>end</i>. Specifically, for an increasing range: <code><i>value</i> &lt; (<i>end</i> + 1e-15)</code> is used to test if <code><i>value</i></code> is in the range.</p>
</blockquote>
<p><code>&gt;&gt;&gt;</code> is like <code>&gt;&gt;</code> except that the third operand (which should be a non-negative integer) is the number of steps:</p>
<pre><code>2 &gt;&gt;&gt; 8 4;    // generator (2 4 6 8)
3 &gt;&gt;&gt; 6 3;    // generator (3 4.5 6)
2 &gt;&gt;&gt; ~7 4;   // generator (2 -1 -4 -7) 
</code></pre>
<blockquote>
<p>Due to floating-point arithmetic, the final element of a range created with <code>&gt;&gt;&gt;</code> may not be identical to <em>end</em>.</p>
</blockquote>
<hr>
<h5><code id="seq">$seq</code></h5>
<p>The <code>$seq</code> operator returns a generator that represents a sequence. The operands of <code>$seq</code> are a <em>value</em>, a <em>test</em> function and an <em>update</em> function. <em>value</em> is passed to <em>test</em>; if <em>test</em> returns truthy, <em>value</em> is passed to <em>update</em> and the result is the new <em>value</em>. These steps are repeated until <em>test</em> is falsy. The generator returned by <code>$seq</code> yields <em>value</em> at each step (after <em>test</em>, before <em>update</em>):</p>
<pre><code>$seq 1 [a &lt; 10] [a * 2];   // generator (1 2 4 8)
</code></pre>
<hr>
<h5><code id="zip">$zip</code></h5>
<p><code>$zip</code> takes one or more iterables and returns a generator that yields the first elements of the iterables as an array, then the second elements, ...</p>
<pre><code>$zip (5 &gt;&gt; 7) (@ 10 20 30);   // generator ([5, 10], [6, 20], [7, 30])
</code></pre>
<p>The generator returns when the end of the shortest iterable is reached.</p>
<blockquote>
<p><a href="?Loops#zipped-loops"><code>$zipEach</code></a> or <a href="?Loops#zipped-loops"><code>$zipMap</code></a> are typically used to iterate over multiple iterables simultaneously. Use <code>$zip</code> if an explicit generator is required or to get the yielded elements as an array at each step.</p>
</blockquote>
<hr>
<h5><code id="nest">$nest</code></h5>
<p>Like <code>$zip</code>, <code>$nest</code> takes one or more iterables and the returned generator yields an array of elements (one from each iterable) each time it is called. However, <code>$nest</code> yields all combinations of elements from the iterables:</p>
<pre><code>$nest (5 &gt;&gt; 7) (@ 10 20);   // generator ([5, 10], [5, 20], [6, 10], 
                            //            [6, 20], [7, 10], [7, 20])
</code></pre>
<p>The generator returned by <code>$nest</code> is analogous to a nested loop. In the above example, the second ('inner') iterable is cycled through once for each element of the first ('outer') iterable.</p>
<p><code>$nest</code> creates a new array from each iterable and yields elements from these arrays. This allows generators (which can only be used once) to be used with <code>$nest</code>. However, it also means that calling the <code>return</code> method of a generator will <em>not</em> prevent <code>$nest</code> yielding further elements.</p>
<blockquote>
<p><a href="?Loops#nested-loops"><code>$nestEach</code></a> or <a href="?Loops#nested-loops"><code>$nestMap</code></a> are typically used for nested loops. Use <code>$nest</code> if an explicit generator is required or to get the yielded elements as an array at each step.</p>
</blockquote>
<hr>
<h5><code>$do</code> <code id="do-and-while">$while</code></h5>
<p><code>$do</code> takes a callback function and returns a generator that repeatedly yields the result of the callback. <code>$do</code> is typically used with <a href="?Loops"><code>$each</code></a> or <a href="?Loops"><code>$map</code></a>:</p>
<pre><code>// prints random numbers until &gt; 0.9
$do [Math |random] $each [
  $print a;
  a &gt; 0.9 ? (c |return)];
</code></pre>
<p><code>$while</code> takes a callback function and returns a generator that repeatedly yields <code>undefined</code> until the callback returns a falsy value:</p>
<pre><code>i = 3;

// prints 3 2 1
$while [i &gt; 0] $each [
  $print i;
  i -= 1];
</code></pre>
<blockquote>
<p>A generator created with <code>$do</code> yields at least once. A generator created with <code>$while</code> may yield zero times.</p>
</blockquote>
<p><code>$asyncDo</code> and <code>$asyncWhile</code> are like <code>$do</code> and <code>$while</code> respectively, but return an asynchronous generator that awaits the callback before yielding. In the following example, <code>$asyncDo</code> creates an asynchronous generator for a stream of data and <code>$awaitEach</code> uses the generator to compute the size of the response:</p>
<pre><code>// web service that returns fake JSON data
url = 'https://jsonplaceholder.typicode.com/photos';

// prints '1071472 bytes' 
\{
  reader = url \fetch $await :body |getReader;
  bytes = 0;
  $asyncDo {reader |read} $awaitEach [data index gen -&gt;
    data :done ? (gen |return) (bytes += data :value :length)];
  + bytes' bytes' $print};
</code></pre>
<p>The above example demonstrates the use of an asynchronous generator. However, note that we could handle the asynchronous part of the task inside the loop callback instead:</p>
<pre><code>url = 'https://jsonplaceholder.typicode.com/photos';

// prints '1071472 bytes' 
\{
  reader = url \fetch $await :body |getReader;
  bytes = 0;
  $awaitEach {  // default synchronous generator, asynchronous callback
    done value #= reader |read $await;
    done ? (c |return) (bytes += value :length)};
  + bytes' bytes' $print};
</code></pre>


<br><br><br>