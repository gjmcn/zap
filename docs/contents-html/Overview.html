<h2>Overview</h2>
<hr>
<p>Zap is a high-level language with a simple, clean syntax and many powerful operators.</p>
<p>Zap compiles to JavaScript and can use JavaScript's built-in objects. JavaScript libraries can be used in Zap and vice-versa.</p>
<h4>Literals</h4>
<pre><code># u 5 v 6    // Object {u: 5, v: 6}
## u 5 v 6   // Map {'u' =&gt; 5, 'v' =&gt; 6}
@ 5 6        // Array [5, 6]
@@ 5 6       // Set {5, 6}
</code></pre>
<h4>Expressions</h4>
<p>Everything in Zap is an expression â€” no blocks, statements or keywords. Except for a few special cases, code reads left to right and the 'current' operator is applied when the next operator or end of the expression is reached:</p>
<pre><code>@ 3 4 5     // [3, 4, 5]
3 @ 4 5     // [3, 4, 5]
3 4 5 @     // [3, 4, 5]

3 + 4 @ 5   // [7, 5]
+ 3 4 @ 5   // [7, 5]
3 4 + @ 5   // [7, 5]
</code></pre>
<p>Basic operators such as <code>+</code> can take more the two operands:</p>
<pre><code>3 4 5 +   // 12
+ 3 4 5   // 12
</code></pre>
<p>Many operators have names rather than symbols:</p>
<pre><code>typeof 5 == 'number' print   // prints (and returns) true
</code></pre>
<h4>Indentation</h4>
<p>Indented blocks or parentheses can be used for precedence:</p>
<pre><code>3 * (4 + 5)   // 27
3 * 
    4 + 5     // 27

x = @ 3 4 5
x each v (print v)   // prints 3 4 5
x each v             
    print v          // prints 3 4 5
</code></pre>
<p>Indented blocks can contain multiple expressions:</p>
<pre><code>// prints 12 30 56
@ 3 4 5 each value index
    z = value + index
    print z ^ 2 + z
</code></pre>
<h4>Line Continuation</h4>
<p>An expression terminates at the end of a line unless the following line opens an indentation block or continues the line with <code>|</code>.</p>
<pre><code>// an array of objects
dogs = 
    @
        #
        | name 'Bill'
        | breed 'boxer'
        | food (@ 'bananas' 'beans' 'biscuits')
    | 
        #
        | name 'Debra'
        | breed 'doberman'
        | food (@ 'dates' 'donuts')

// on fewer lines, but harder to read:
dogs = @
| (# name 'Bill'  breed 'boxer'    food (@ 'bananas' 'beans' 'biscuits')
| (# name 'Debra' breed 'doberman' food (@ 'dates' 'donuts'))
</code></pre>
<h4>Functions</h4>
<p>The <code>fun</code> operator creates a function, <code>\</code> calls a function. Operators for calling functions are special: the first right operand is always the function:</p>
<pre><code>double = fun x (2 * x)   // body in parentheses

add = fun x y
    x + y                // body in indented block

\double 5 \add 20        // 30
5 \double \add 20        // 30
\add (\double 5) 20      // 30
</code></pre>
<p>Bracket functions have parameters <code>a</code>, <code>b</code> and <code>c</code> and are ideal for simple 'one-liners':</p>
<pre><code>add = [a + b]   // function
</code></pre>
<p><code>scope</code> and <code>as</code> are Zap's equivalent to IIFEs (immediately-invoked function expressions) or blocks. <code>scope</code> takes no arguments, <code>as</code> takes one:</p>
<pre><code>x = scope
    y = 2 + 3
    y ^ 2 + y   // 30
x               // 30

x = 2 + 3 as y
    y ^ 2 + y   // 30
x               // 30
</code></pre>
<p>The <code>~</code> operator calls a method:</p>
<pre><code>'abcd' ~slice 1 3 ~repeat 2   // 'bcbc'
</code></pre>
<h4>Generators</h4>
<p><code>yield</code> and <code>yieldFrom</code> can be used in the body of functions, <code>scope</code>, <code>as</code> and loops:</p>
<pre><code>g = 5 do i (yield i)   // generator

g ~next   // {value: 0, done: false}
g ~next   // {value: 1, done: false}
</code></pre>
<p>There are also range operators that create generators:</p>
<pre><code>1 to 3           // generator (1 2 3)
1 to 7 2         // generator (1 3 5 7)
1 7 linSpace 4   // generator (1 3 5 7)
</code></pre>
<h4>Iterables</h4>
<p>There are lots of operators for working with iterables (arrays, sets, generators etc.). For example:</p>
<pre><code>s = @@ 5 6 7              // Set {5, 6, 7}
s array                   // [5, 6, 7]
s each x (x + 10 print)   // prints 15 16 17,
s map x (x + 10)          // [15, 16, 17]
s max                     // 7
s sum                     // 18
s filter [a &gt; 5]          // [6, 7] 
s group [a &gt; 5]           // Map {false =&gt; [5], true =&gt; [6, 7]}
</code></pre>
<p>Backticks tell an arithmetic, logical or comparison operator to iterate over an operand:</p>
<pre><code>x = @ 5 6 7   // [5, 6, 7]
x  `+  10     // [15, 16, 17]       
10  +` x      // [15, 16, 17]
x  `+` x      // [10, 12, 14]

'ab'  +  'cd'   // 'abcd'
'ab' `+  'cd'   // ['acd', bcd']
'ab' `+` 'cd'   // ['ac', 'bd']
</code></pre>
<h4>Elementwise</h4>
<p>The many elementwise operators can be used with iterables or non-iterables:</p>
<pre><code>@ 4 9 16 sqrt   // [2, 3, 4]
4 sqrt          // 2
</code></pre>
<h4>Classes</h4>
<p>Use <code>class</code> to write a constructor and <code>extends</code> for a subclass. <code>::</code> gets a property from the prototype of an object so can be used to add methods:</p>
<pre><code>// class with empty body: params become properties
Cat = class name ()

// subclass with empty body: calls constructor of parent class
Lion = extends Cat ()
Lion ::speak = fun mood
    + 'I am '(this :name)' the 'mood' lion'

leo = new Lion 'Leo'   // Lion {name: &quot;Leo&quot;}
leo ~speak 'hungry'    // 'I am Leo the hungry lion'
</code></pre>
<h4>Asynchronous Operators</h4>
<p>Except for <code>class</code> and <code>extends</code>, all operators that take a body operand have an asynchronous version:</p>
<pre><code>// prints the string on the final line (and returns a promise
// that resolves to the string)
asyncScope
    data = 'data.json' \fetch await ~json await
    'The data has '(data :length)' rows' print
</code></pre>
<h4>DOM</h4>
<p>DOM operators work with individual HTML/SVG elements, iterables of elements and CSS selector strings:</p>
<pre><code>// set color of each span with class danger to red
'span.danger' style 'color' 'red'      

// create 5 divs, apply various operators, add divs to body
5 $div 
| style 'cursor' 'pointer'
| addClass 'btn'
| text 'vanish'
| on 'click' [remove this]
| into 'body'
</code></pre>
<p>Data can be encoded as (and is automatically attached to) elements:</p>
<pre><code>@ 5 6 7 encode 'p' text [a]   // [&lt;p&gt;5&lt;/p&gt;, &lt;p&gt;6&lt;/p&gt;, &lt;p&gt;7&lt;/p&gt;] 
</code></pre>


<br><br><br>