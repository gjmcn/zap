<h2>Object-Oriented Programming</h2>
<hr>
<p>There are various options for object-oriented programming in Zap. For example:</p>
<ol>
<li>
<p>Data in objects; functions to use and manipulate them:</p>
<pre><code>fighter = [name -&gt;
  # stamina 100 ::name];

paladin = [name -&gt; 
  \fighter name :mana 100];

fight = [player -&gt;
  + (player :name)' slashes at the foe' $print;
  player -:stamina 1];

cast = [player spell -&gt;
  + (player :name)' casts 'spell $print;
  player -:mana 1];
  
alex = \fighter 'Alex';
alex \fight;             // prints 'Alex slashes at the foe'

cody = \paladin 'Cody';
cody \fight;             // prints 'Cody slashes at the foe'
cody \cast 'fireball';   // prints 'Cody casts fireball
</code></pre>
</li>
<li>
<p>Methods instead of standalone functions:</p>
<pre><code>fighter = [name -&gt;
  # stamina 100
    fight [
      + (this :name)' slashes at the foe' $print;
      this -:stamina 1]
    ::name];

paladin = [name -&gt;
  \fighter name
    :mana 100
    :cast [spell -&gt;
      + (this :name)' casts 'spell $print;
      this -:mana 1]];

alex = \fighter 'Alex';
alex |fight;             // prints 'Alex slashes at the foe'

cody = \paladin 'Cody';
cody |fight;             // prints 'Cody slashes at the foe'
cody |cast 'fireball';   // prints 'Cody casts fireball'
</code></pre>
</li>
<li>
<p>Closures:</p>
<pre><code>fighter = [name -&gt;
  stamina = 100;
  # fight [
    + name' slashes at the foe' $print;
    stamina -= 1]];

paladin = [name -&gt;
  mana = 100;
  \fighter name
    :cast [spell -&gt;
      + name' casts 'spell $print;
      mana -= 1]];

alex = \fighter 'Alex';
alex |fight;             // prints 'Alex slashes at the foe'

cody = \paladin 'Cody';
cody |fight;             // prints 'Cody slashes at the foe'
cody |cast 'fireball';   // prints 'Cody casts fireball'
</code></pre>
</li>
<li>
<p>Create 'classes' independently; use functions to add methods:</p>
<pre><code>canFight = [player -&gt;
  player :fight [
    + (this :name)' slashes at the foe' $print;
    this -:stamina 1]];

canCast = [player -&gt;
  player :cast [spell -&gt;
    + (this :name)' casts 'spell $print;
    this -:mana 1]];

fighter = [name -&gt;
  # stamina 100 ::name \canFight];

paladin = [name -&gt; 
  # stamina 100 mana 100 ::name \canFight \canCast];
  
alex = \fighter 'Alex';
alex |fight;             // prints 'Alex slashes at the foe'

cody = \paladin 'Cody';
cody |fight;             // prints 'Cody slashes at the foe'
cody |cast 'fireball';   // prints 'Cody casts fireball'
</code></pre>
</li>
<li id="extends-example">
<p>Prototype-based object-orientation:</p>
<pre><code>Fighter = $class [name -&gt;
  this ::name :stamina 100];

Fighter \:fight [
  + (this :name)' slashes at the foe' $print;
  this -:stamina 1];

Paladin = $extends Fighter [name -&gt;
  \super name;
  this :mana 100];

Paladin \:cast [spell -&gt;
  + (this :name)' casts 'spell $print;
  this -:mana 1];

alex = $new Fighter 'Alex';
alex |fight;                 // prints 'Alex slashes at the foe'

cody = $new Paladin 'Cody';
cody |fight;                 // prints 'Cody slashes at the foe'
cody |cast 'fireball';       // prints 'Cody casts fireball'
</code></pre>
</li>
</ol>
<p>In the final example, we use <code>$class</code> to create a class and <code>$extends</code> to create a subclass:</p>
<ul>
<li>
<p><code>$class</code> takes an optional constructor function and returns a class. If used, the constructor must be a function literal.</p>
</li>
<li>
<p>The distinction between a class and a standard function is rarely important — we could omit <code>$class</code> from the above example and simply assign the function to <code>Fighter</code>.</p>
</li>
<li>
<p><code>$extends</code> takes a parent class/function and an optional constructor function, and returns a class. If used, the constructor must be a function literal. The constructor defaults to: <code>[...args -&gt; \super ...args]</code>.</p>
</li>
<li>
<p>When using <code>$extends</code>, <code>super</code> is used inside the constructor to call the constructor of the parent class. <code>super</code> must be called before <code>this</code> is used — and must be called somewhere in the constructor even if <code>this</code> is not used.</p>
</li>
<li>
<p>For both <code>$class</code> and <code>$extends</code>, the return value of the constructor is ignored.</p>
</li>
<li>
<p><code>$extends</code> can be used to subclass built-in objects, e.g. <code>$extends Array</code>.</p>
</li>
</ul>
<blockquote>
<p>The examples in this section are adapted from <a href="https://medium.com/code-monkey/object-composition-in-javascript-2f9b9077b5e6">here</a>.</p>
</blockquote>


<br><br><br>