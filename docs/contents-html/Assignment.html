<h2>Assignment</h2>
<hr>
<p>Use <code>=</code> for standard assignment:</p>
<pre><code>x = 5;   // 5
x;       // 5
</code></pre>
<blockquote>
<p>Assignment operators <a href="?Evaluation#assignment-precedence">do not follow the normal position and precedence rules</a>.</p>
</blockquote>
<h4>Update-Assignment</h4>
<p>Use <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>^=</code> for update-assignments:</p>
<pre><code>x = 5;     // 5
x += 10;   // 15
x;         // 15
</code></pre>
<h4 id="conditional-assignment">Conditional Assignment</h4>
<p>Use <code>?=</code> for <em>conditional assignment</em>: if the variable (the first operand) is currently <code>undefined</code> or <code>null</code>, the second operand is evaluated and the result is assigned to the variable. If the variable <em>is not</em> currently <code>undefined</code> or <code>null</code>, the variable is assigned its current value and the second operand is not evaluated (short-circuit evaluation):</p>
<pre><code>x = null;
x ?= 5;    // 5 (x is 5)
x ?= 10;   // 5 (x is 5)
</code></pre>
<h4>Assignment and Options</h4>
<p>The assignment operator <a href="?Writing-Functions#options"><code>=:</code></a> is discussed in <a href="?Writing-Functions">Writing Functions</a>.</p>
<h4 id="destructuring">Destructuring</h4>
<p>Use <code>#=</code> to destructure an object:</p>
<pre><code>o = # h 5 i 6 j 7;
h z j #= o;   // returns o, h is 5, z is undefined, j is 7
</code></pre>
<p>Use <code>@=</code> to destructure an iterable. Use <code>null</code> to skip entries:</p>
<pre><code>x = @ 5 6 7;
u v @= x;             // returns x, u is 5, v is 6
u null v @= x;        // returns x, u is 5, v is 7

s = @@ 5 6;   // Set {5, 6}
u v @= s;     // returns s, u is 5, v is 6
</code></pre>
<p>Rest syntax can be used when destructuring:</p>
<pre><code>o = # u 5 v 6 w 7;
v ...z #= o;   // returns o, v is 6, z is {u: 5, w: 7}

x = @ 5 6 7;
s ...t @= x;   // returns x, s is 5, t is [6, 7]
</code></pre>


<br><br><br>